#include <iostream>

using namespace std;

// 풀이.
// 이것도 정답율 33퍼밖에 안되는 어려운 문제인데 생각보다 쉽게 풀었다. 다행이다.
// 가장 긴 수를 구하는 것은 거의 보자마자 생각이 났다. 작은 수일지라도 여러개의 수를 만들어
// 최대한 자리수를 늘리는 것이었다. 즉 2로 나누어 최대한 1을 만들되, 나머지가 존재한다면 그 나머지와
// 기존의 1을 하나빼서 7로 만들어 맨앞에 두면 된다. 다만, 최대 50자리가 넘을수도 있기에 long long으로도 불가능
// 하여 문자열로 만들어야만 했다. 가장 작은 수가 조금 복잡해보였다.
// 결과적으로는 백트래킹과 dp를 사용하면 되는데 주의해야할 점은 6개를 사용하는 부분이 다르다는 것이다.
// 맨 앞자리가 0이 나올순 없기 때문에 dp[6]은 0이 아닌 9가 되어야 하지만 실제로 성냥개비값을 대입할때의
// rot[6]은 9가 아닌 0이 되어야 가장 작은수를 구할수 있다. 이후 현재의 성냥 개수 num에서 구할수 있는 모든 값들을
// 구하여 반환하면 된다. 또한 int값을 벗어날수 있기에 long long 타입으로 구해야한다.

// 자세한 설명은 주석으로 남긴다.

long long dp[101], rot[8] = { 0, 0, 1, 7, 4, 2, 0, 8 };
int T, N;

// 모든 경우를 구해 num개일때의 최소값을 구하는 함수.
long long BackTrack(int num)
{
    long long& ans = dp[num];
    if (ans != -1)
        return ans;

    // long long 으로 표현할수 있는 최대값.
    ans = 9223372036854775807;
    // 각 성냥개비의 수로 구할수 있는 최소값들을 대입해본다.
    for (int i = 2; i <= 7; ++i)
        // num - i가 1보다 같거나 작다면 구할수 없다.
        if (num - i >= 2)
            // 맨 뒷자리부터 구하기 때문에 이후 구하는 값을 10 곱하고 현재값을 더한다.
            ans = min(ans, BackTrack(num - i) * 10 + rot[i]);
    return ans;
}

void MakeAnswer()
{
    for (int i = 0; i <= 100; ++i)
        dp[i] = -1;
    dp[2] = 1;
    dp[3] = 7;
    dp[4] = 4;
    dp[5] = 2;
    // 상술하였듯 맨 처음값이 0이면 안되기 때문에 dp[6]의 값은 6개로 만들수 있는 두번째 작은값인 6이 된다.
    dp[6] = 6;
    dp[7] = 8;
    for (int iter = 0; iter < T; ++iter)
    {
        cin >> N;
        cout << BackTrack(N) << ' ';
        // 제일 큰것은 다음과 같다.
        // 1. 2로 나누어 몫을 구한다.
        // 2. 나머지를 구한다. 나머지가 존재한다면 1번에서 구한값은 -= 1되며 맨 앞자리는 7이다.
        // 3. 나머지가 0이라면 1번에서 구한값만큼 1로 채운다.
        // 상술하였듯 최대 50자리가 넘을수 있다. long long 으로도 불가능하기에 문자열로 구한다.
        int div = N / 2 - 1;
        string answer = N % 2 != 0 ? "7" : "1";
        for (int i = 0; i < div; ++i)
            answer += '1';
        cout << answer << '\n';
    }
}

void Input()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> T;
}

int main()
{
    Input();
    MakeAnswer();
    return 0;
}