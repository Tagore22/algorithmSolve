#include <iostream>

using namespace std;

// 풀이.
// 최초의 접근 자체는 좋았다. 어렵게 생각할것 없이 1부터 11, 111처럼 자리수를 늘려가며 주어지는 수 N으로 나누어지는지를
// 확인하면 되었다. 다만 한가지 놓친 부분이 있는데 9999같은 경우의 답은 36이 된다. 따라서 아무리 long long타입으로 값을 늘려가도
// 찾을수가 없어 결국엔 오버플로우가 발생하여 무한으로 순회하게 된다. 결국 값을 줄여줄 필요가 있었다. 이때 모듈라 연산이
// 적용되는데 종만북 893페이지에 나온 식은 다음과 같다.

// A * 10 + 1 mod N = A mod N * 10 + 1 mod N

// 즉 증가한 A의 나머지 값은 A의 나머지의 증가값의 나머지 값과 동일하다. 따라서 A를 나머지값으로 변환해나간다면
// 결코 10000보다 커질일이 없으므로 위 오버플로우 문제를 해결할수 있다.

// 자세한 설명은 주석으로 남긴다.

int N;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int cur, answer;
    while (cin >> N)
    {
        // 초창기 값과 그 자리수의 수.
        cur = 1, answer = 1;
        while (cur % N != 0)
        {
            // 현재값 cur을 증가시키기 전에 그 나머지값으로 변환하여 상술한 오버플로우 문제를 방지한다.
            cur %= N;
            // 현재값 cur의 증가와 자리수 answer의 증가.
            cur *= 10;
            ++cur;
            ++answer;
        }

        cout << answer << '\n';
    }
    return 0;
}