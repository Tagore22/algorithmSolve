#include <iostream>

using namespace std;

// 풀이.
// 두 수 A, B가 주어질때 A ~ B까지의 수를 이진법으로 변환하였을때의 1의 개수들을 구하는 것이다.
// 우선 누적합으로 (0 ~ B까지의 총합) - (0 ~ A - 1 까지의 총합)을 구하여 A ~ B까지의 합을 구한다.
// 각 총합은 DP를 이용하면 된다. https://degurii.tistory.com/158 에서 예시를 들어 설명하듯
// 뒷자리수는 매번 반복된다. 예를 들어 10 이라면

// 00, 01, 10, 11으로 가장 큰 왼쪽에서 첫번째 자리를 제외하고 그 이전의 나왔던 방식이 두번 반복된다.
// 그후 맨 앞자리의 수들을 더하면 된다. 따라서 점화식은 dp[i - 1] + (1LL << i)가 된다.

// 이렇게 DP들을 구해놓으면 각각 A와 B의 개수를 구하면 되는데 이때 맨 앞자리부터 현재 자리가 1이 될때까지의
// 1의 개수들을 각 자리마다 구해서 더해나간다. 예를 들어 10101 = 21이라면 맨 왼쪽자리부터 순회하는데
// 10000이 되기까지의 수는 dp[3]과 같다. 이후 10000부터 10101가 될때까지의 개수들(맨 왼쪽)을 더해주어야
// 하는데 이것은 현재수 - 2의 현재 자리수의 제곱 + 1로 구할수 있다. (21 - 16 + 1 = 5)

// 문제도 복잡하고 풀기도 복잡한 문제다. 다 이해는 했으나 설명하려니 어렵다.
// 자세한 설명은 주석으로 남긴다.

long long dp[55];
long long A, B;
const int MAX = 55;

// DP를 구하는 함수.
void CalDP()
{
    // 0번째(2의 0제곱)자리는 늘 1이다.
    dp[0] = 1;
    // 최대 55자리이기에 55까지 반복한다.
    for (int i = 1; i < MAX; ++i)
        // 상술하였듯 뒷자리는 계속 반복된다. 따라서 이전 자리 * 2 + 맨 앞자리의 1의 개수를 더해준다.
        dp[i] = dp[i - 1] * 2 + (1LL << i);
}

// 0 ~ num까지의 1의 개수를 구하여 반환하는 함수.
long long CalOne(long long num)
{
    // 0이 아닌 1까지만 내려가면서 순회하기에 맨 마지막 자리를 구하지 못한다.
    // 따라서 num의 맨 마지막 2진수가 0이라면 0로, 1이라면 1로 시작한다.
    long long ans = num & 1;
    for (int i = MAX; i > 0; --i)
    {
        // 현재 자리가 1이라면 개수를 구해 더한다.
        if (num & (1LL << i))
        {
            // 현재 자리수까지의 수 + 맨 앞자리의 1의 수(이후의 자리수가 내려갔을때 맨 앞자리가 1이지만 
            // 뒷부분만 구해지기에 더해지지 않는 것을 미리 더해준다).
            ans += dp[i - 1] + num - (1LL << i) + 1;
            // 현재수 num을 감소시켜 1을 0으로 만든다.
            num -= (1LL << i);
        }
    }
    return ans;
}

void MakeAnswer()
{
    CalDP();

    cout << CalOne(B) - CalOne(A - 1) << '\n';
}

void Input()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> A >> B;
}

int main()
{
    Input();
    MakeAnswer();
    return 0;
}