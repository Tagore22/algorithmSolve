#include <iostream>

using namespace std;

// 풀이.
// 조금은 생각을 필요로 하는 문제다. 정리해부터 해보자면 다음과 같다.

// 1. N을 K개의 수들로 나누어야한다.
// 2. 가장 작은값은 최소 1이 되어야하며 모든 수는 전부 달라야한다.
// 3. 가장 큰값과 작은값의 차이가 최소여야한다.

// 우선 1 ~ K까지의 합 sum을 구해 K개의 수들로 만들수 있는 최소값을 구한다. 이때
// 1. sum이 N보다 크다면 아예 나누는것 자체가 불가능하기에 -1을 출력한다.
// 2. sum이 N과 같거나 작다면 차이값을 올바르게 나누어주어야한다. 따라서 sum에서 N을 빼고
// K로 나눈 나머지값을 살핀다. 이 값이 0이라면 각 값들에게 1씩 동일하게 나누어줘서 가장 큰값과
// 작은값의 차이는 원래대로 K - 1이 되며, 0이 아니라면 가장 큰수부터 1씩 나누어주게 되어
// 가장 큰값과 작은값의 차이는 K가 된다. 맨 마지막부터 나누어주는 이유는 이미 모든값들은
// 1씩 차이가 난다. 모든값들에게 1씩 나누어줄수 없으므로 언젠가 현재값과 다음값이 동일해지는
// 시기가 오며, 이건 위의 규칙에 어긋나므로 불가능한 경우이기 때문이다.

// 자세한 설명은 주석으로 남긴다.

int main()
{
    int N, K;
    cin >> N >> K;

    // 1 ~ K까지의 합을 구한다
    int sum = K * (K + 1) / 2;
    // 만약 합 sum이 N보다 크다면 N은 K로 올바르게 나눌수 없다
    if (sum > N)
    {
        cout << -1 << '\n';
    }
    // sum이 N과 같거나 큰 작은 경우
    else
    {
        // sum에서 N을 뺀 나머지값들을 K로 나누어 그 나머지값들을 확인한다
        // 0이라면, 모든 수에게 동일한 값을 줄수 있기에 최소값과 최대값의 차이는 변하지 않으나
        // 나머지가 0이 아니라면 맨 뒤부터 1씩 증가하기에 최소값과 최대값의 차이는 K - 1에서 K로 변한다
        sum -= N;
        sum %= K;
        cout << (sum == 0 ? K - 1 : K) << '\n';
    }
    return 0;
}