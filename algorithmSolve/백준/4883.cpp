#include <iostream>

using namespace std;

// 풀이.
// 오랜만에 난이도가 있는 문제였다. (0, 1)번째칸에서 (N - 1, 1)까지 이동하는 최소값을 구하는
// 문제인데 움직일 수 있는 방향은 오른쪽, 아랫쪽, 좌하단, 우하단 이렇게 4방향이다.
// 처음에는 BFS를 생각했으나 시간초과가 났는데 지금 생각해보면 모든 경우의 수를 구하기 때문에
// 최대 30만의 4제곱에 가까운 연산량을 구하기 때문일 것이다. 따라서 로직을 바꾸어야했다.
// DP를 이용함은 분명하기에 조금더 간단하면서도 모든칸을 순회하는 것만으로 각 dp값을 구하는
// 로직을 생각해보았다. 의외로 간단한데 말 그대로 모든 칸을 순회하며 값을 구하면 된다.
// 예를 들어 (3, 5)라고 하면 (3, 4)에서 오른쪽으로, (2, 5)에서 아랫쪽으로, (2, 6)에서 
// 좌하단으로, (2, 4)에서 우하단으로 내려올 수 있으므로 각 경우를 구하여 최소값을
// dp[3][5]로 저장해두면 된다. 다만 한가지 놓친 부분이 있었는데 (0, 2)이다.
// 실제로 가장 처음 시작하는 위치값은 (0, 1)이지만 (0, 2)가 음수라면 반드시 이곳을
// 지나쳐야한다. 사실 음수를 전혀 생각하지 못하고 있었다. 따라서 후술할 부분을 추가하여
// 정답을 맞출 수 있었다. 

// 자세한 설명은 주석으로 남긴다.

int K = 0, N;
const int MAX = 100000;
int board[MAX][3], dp[MAX][3];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    while (true)
    {
        ++K;
        cin >> N;
        // N이 0이라면 프로그램 종료
        if (N == 0)
            break;
        // 입력과 동시에 dp값의 초기화를 동시에 수행하여 최적화
        for (int i = 0; i < N; ++i)
        {
            for (int j = 0; j < 3; ++j)
            {
                cin >> board[i][j];
                dp[i][j] = 987654321;
            }
        }
        // 시작값 초기화
        dp[0][1] = board[0][1];
        // 상술한 부분. (0, 2)는 필요없는 부분이라고 생각했으나
        // 이곳이 음수고 시작값이 양수라면 이곳을 반드시 지나쳐야 
        // 최소값이 되므로 어느 상황이든 반드시 초기화 해야한다
        dp[0][2] = min(dp[0][2], dp[0][1] + board[0][2]);
        // 모든 값을 순회하며 dp값을 계산한다
        for (int i = 1; i < N; ++i)
        {
            for (int j = 0; j < 3; ++j)
            {
                // 위쪽칸에서 내려온 경우
                for (int z = -1; z < 2; ++z)
                {
                    int nx = j + z;
                    if (nx < 0 || nx > 2)
                        continue;
                    dp[i][j] = min(dp[i][j], dp[i - 1][nx] + board[i][j]);
                }
                // 왼쪽에서 온 경우
                if (j != 0)
                    dp[i][j] = min(dp[i][j], dp[i][j - 1] + board[i][j]);
            }
        }
        cout << K << ". " << dp[N - 1][1] << '\n';
    }
    return 0;
}