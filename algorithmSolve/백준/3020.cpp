#include <iostream>

using namespace std;

// 풀이.
// 오랜만에 골드 문제 풀었는데 하루종일 풀었다. 누적합에 대한 색다른 관점을 필요로 하는 문제였다.
// 석순과 종유석 두 구간을 둘로 나누어야 했다. 석순(아래)부터 보자면 모든 칸을 순회하지 않고 언젠가 풀었던 방식처럼
// 높이를 인덱스로 하는 배열에 n 높이의 석순이 몇개 나왔는지를 저장한다. 맨 뒤부터 앞으로 이전값을 현재값에 더하면
// 현재 위치에서 돌파해야하는 장애물의 수가 계산된다. 이것을 종유석에도 대입하면 되는데 그게 좀 이해하기 어려웠다.
// 결과적으로는 180도로 회전시켜보는 것과 같은데 석순은 아래부터 1로 시작한다. 하지만 종유석은 위부터 1로 시작하기 때문에
// 180도 회전시켜서 마찬가지로 밑에부터 1로 시작하게 하면 된다. 그리고 높이는 길이로 보지 않고 끝에 닿는 위치를 생각하면 되었다.
// 예를 들어 종유석이 위부터 3의 길이만큼 나아있다면 아래부터 시작해서 위에서부터 3까지 나아가는 것으로 치면 되는 것이다.
// 그리고 180도 회전시킨 상태이기 때문에 이전처럼 뒤에서부터 더하지 않고 맨 앞부터 다음값을 더해나가면 된다. 그 후 최종적으로
// 각 구간에서 종유석과 석순을 돌파해야하는 값들을 모두 더해 최소값과 그 개수를 출력하면 된다.

// 자세한 설명은 주석으로 남긴다.

int up[500001] = { 0, }, bottom[500001] = { 0, };
int N, H;

void MakeAnswer()
{
    int b, u;
    // 종유석과 석순의 길이가 아닌 도달하는 위치를 저장한다.
    for (int i = 0; i < N / 2; ++i)
    {
        cin >> b >> u;
        ++bottom[b];
        // 상술한대로 종유석은 아래서부터가 아닌 위에서부터 길이를 표기한다. 하지만 아래서부터로 통일하기 위해
        // H + 1 - u를 한다.
        ++up[H + 1 - u];
    }
    // 누적합을 이용하여 맨 뒤부터 i += i + 1로 각 구간별 돌파해야하는 석순값을 구한다.
    for (int i = H - 1; i >= 1; --i)
        bottom[i] += bottom[i + 1];
    pair<int, int> answer = make_pair(200001, 0);
    // 상술한대로 종유석은 180도 회전된 상태이므로 뒤가 아닌 앞부터 i += i - 1을 구한다.
    for (int i = 1; i <= H; ++i)
    {
        up[i] += up[i - 1];
        // 돌파해야하는 종유석과 석순값을 더하여 최종적으로 최소값과 그 개수를 구하여 출력한다.
        if (up[i] + bottom[i] < answer.first)
            answer = make_pair(up[i] + bottom[i], 1);
        else if (up[i] + bottom[i] == answer.first)
            ++answer.second;
    }
    cout << answer.first << ' ' << answer.second << '\n';
}

void Input()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> N >> H;
}

int main()
{
    Input();
    MakeAnswer();
    return 0;
}