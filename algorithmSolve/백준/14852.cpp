#include <iostream>

using namespace std;

// 풀이.
// 26퍼센트라는 정답율에 맞게 어려운 문제였다. 타일을 채우는 기본적인 방법으로는 끝쪽 1개 혹은 2개가 비워졌다는
// 가정하에 기존값 * 1칸을 채울 경우 + 기존칸 * 2칸을 채울 경우에서 중복되는 방법을 제외하면 되는데 이번 문제는
// 1x1 타일이 있기 때문에 예외의 경우가 존재했다. 이 예외의 경우는 2x3칸 이상에서 무조건 2가지 경우가 존재하기에
// 상술한 1칸, 2칸을 채운 경우에 N - 3 ~ 0개까지의 값을 추가로 더해주어야 한다.
// 또한, 추가적으로 더해주는 부분에서 2중 for문과도 같은 최대 N제곱의 연산이 존재하기 때문에 dp를 1차원으로 구현하면
// N의 최대값 100만 * 100만으로 인해 시간초과에 걸린다. 따라서 2차원 배열을 이용하던가 또다른 1차원 배열을 사용하여
// 누적합을 구해나가며 구현해야 한다.

// 자세한 설명은 주석으로 남긴다.

int N;
long long dp[1000001][2];
const int DIV = 1000000007;

void MakeAnswer()
{
    // dp의 초기화.
    dp[1][0] = 2;
    dp[2][0] = 7;
    // 상술한대로 예외의 경우는 N이 3일때부터 존재하며 그 수는 N에 상관없이 1이다.
    dp[2][1] = 1;
    for (int i = 3; i <= N; ++i)
    {
        // 예외 경우를 구하는 부분. dp[i - 1][1]은 기존의 구한 예외들의 총합이며,
        // dp[i - 1][0]은 예외 부분 3을 제외한 나머지 타일의 경우값이다. 실제로는 예외수(1) * 타머지 타일(dp[i - 3])과 같다.
        dp[i][1] = dp[i - 3][0] + dp[i - 1][1];
        // 1칸을 채우는 경우 + 2칸을 채우는 경우 + 예외의 경우.
        dp[i][0] = (dp[i - 1][0] * 2 + dp[i - 2][0] * 3 + dp[i][1] * 2) % DIV;
    }
    cout << dp[N][0] << '\n';
}

void Input()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> N;
}

int main()
{
    Input();
    MakeAnswer();
    return 0;
}