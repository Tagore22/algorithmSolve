#include <iostream>

using namespace std;

// 풀이.
// 개미가 대각선으로만 이동이 가능할때 T시간 이후의 위치를 구하는 문제다.
// 처음에는 1시간씩 이동하는 위치를 모두 구했는데 T가 최대 2억이기 때문에
// 시간 초과에 걸렸다. 그래서 가로, 세로 각각 구하기로 하였다.
// 처음에는 무조건 우상단으로 이동하기 때문에 맨 우측인 W와 맨 상단인 H까지
// 이동시킨후 남은 T를 W 혹은 H로 나누어 반복을 제외시킨다. 이때 나눈 수가
// 짝수라면 W 혹은 H까지 되돌아온 것이고 홀수라면 되돌아오지 못한 0임을 알수 있다.
// 여기에 마지막으로 나머지값을 처리해주어야 하는데 짝수라면 감소시키고
// 홀수라면 증가시키면 된다. 

// 그리고 한가지 빼먹은 것이 있었는데 T가 작아서 아예 W 혹은 H까지 이동시키지 못하는 경우가 있었다.
// 예를 들어 6, 4, 0, 0, 2가 그런 경우다. 이 경우에는 6, 4까지 가지도 못하고 2, 2에서 끝나기 때문이다.
// 따라서 각각 W - P 혹은 H - Q가 T보다 큰경우에는 그냥 현재 위치에서 T만큼 더해주면 된다.
// 정답율이 낮은 만큼 실버지만 꽤 까다로웠다.

// 자세한 설명은 주석으로 남긴다.

int W, H, P, Q, T;

void MakeAnswer()
{
    // 아예 W까지 이동할수 없는 경우 현재 위치에서
    // T만큼만 더해준다.
    if (W - P > T)
    {
        P += T;
    }
    // W까지 이동이 가능할 경우.
    else
    {
        int r_T = T;
        // W까지 이동시킨만큼 T를 감소시킨다.
        r_T -= W - P;
        // 감소시킨 T인 r_T를 W로 나누어준다. 이때 짝수라면 되돌아온 것이고
        // 홀수라면 되돌아 오지 못한 것이다.
        int r_move = r_T / W;
        // 나머지값은 이후에 더해주거나 빼주어야 한다.
        int r_plus = r_T % W;
        // 짝수인 경우 되돌아와서 다시 0쪽으로 감소시켜야 하고
        // 홀수인 경우 0에서 다시 증가하여야 한다.
        P = r_move % 2 == 0 ? W - r_plus : 0 + r_plus;
    }
    // 위와 동일하다.
    if (H - Q > T)
    {
        Q += T;
    }
    else
    {
        int u_T = T;
        u_T -= H - Q;
        int u_move = u_T / H;
        int u_plus = u_T % H;
        Q = u_move % 2 == 0 ? H - u_plus : 0 + u_plus;
    }
    cout << P << ' ' << Q << '\n';
}

void Input()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> W >> H >> P >> Q >> T;
}

int main()
{
    Input();
    MakeAnswer();
    return 0;
}