#include <iostream>
#include <cstring>

using namespace std;

// 풀이
// 3X4 타일을 생각해보자. 예시에 3X2는 3이라고 나와있기에 4칸은 3 * 3으로 9이다. 다만 양 옆이 I로 시작하는 2칸에서는 만들수 없는
// 새로운 모양의 타일이 있다. 이 타일은 각 칸마다 총 2가지가 있다. 그렇기에 4칸에선 총 11개의 모양을 만들수 있다.
// 
// 6칸을 생각해보자. 2X4칸 혹은 4X2칸으로 만들수 있다. 그런데 2X4칸을 구하던 4X2칸을 구하던 앞서 말한 I로 시작하는 특별한 모양을
// 제외하고는 거의 모든 경우가 겹친다. 그렇기에 굳이 두번 구하지 않고 4X2칸만을 구하고(특별한 모양이 왼쪽에 있을 경우가 여기에 포함됨)
// 특별한 모양이 오른쪽에 있을 2X4칸을 구하면 된다. 상술하였듯 특별한 모양은 각 칸마다 2개가 있기에 2 * 2칸을 구하고 6칸만의 특별한 모양을 더해서
// 총 6이 나와서 6칸에서는 [4] * [2] + [2] * 2 + 2가 되어 41이 나온다.
//
// 8칸을 생각해보자. 6X2, 4X4, 2X6이 있다. 먼저 6X2를 구하면 41 * 3이 되어 123이 나오고(특별한 모양이 왼쪽에 있을 경우가 여기에 포함됨)
// 4X4에서 역시 거의 모든 모양이 겹치기에 겹치지 않는 유일한 모양인 4칸의 특별한 모양이 오른쪽에 있을 경우를 구한다.
// 즉 [4] * 2가 되어 22가 된다. 2X6도 거의 모든 모양이 겹치는데 6칸만의 특별한 모양이 오른쪽에 있을 경우인 [2] * 2가 되어 6이 된다.
// 마지막으로 8칸만의 특별한 모양이 2개가 추가 되어 총 값은 [6] * [2] + [4] * 2 + [2] * 2 + 2 = 153이 된다.
//
// 위를 보면 알수 있듯이 DP를 이용하여 겹치지 않는 초기값을 구하고, 특별한 경우만을 따로 구해 더해주면 된다.
// 점화식은 [N - 2] * [2] + [N - 4] * 2.....[0] * 2가 된다.

int answer[31];
int N;

void MakeAnswer()
{
    memset(answer, 0, sizeof(answer));
    answer[0] = 1;
    answer[2] = 3;

    for (int i = 4; i <= N; ++i)
    {
        answer[i] = answer[i - 2] * answer[2];
        for (int j = 4; j <= i; j += 2)
            answer[i] += answer[i - j] * 2;
    }

    cout << answer[N] << '\n';
}

void Input()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> N;
}

int main()
{
    Input();
    MakeAnswer();
    return 0;
}