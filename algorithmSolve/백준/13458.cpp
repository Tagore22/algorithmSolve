#include <iostream>

using namespace std;

// 풀이.
// 정답율을 보면 알수 있듯이 브론즈치고는 난이도가 있는 문제였다.
// 모든 응시자를 감시할수 있는 감독관의 최소값을 출력하는 문제인데
// 다음과 같은 조건이 있다.

// 총감독관은 단 한명뿐이며, 부감독관은 여러명이 존재할수 있음.

// 따라서 응시자들중 총감독관이 감시할수 있는 인원을 제외하고 나머지를 부감독관이 감시할수 있는 수만큼
// 나눈다. 그후 나머지가 존재한다면 다시 한명의 부감독관을 추가하여 모두 감시하면 되는데
// 만약 총감독관이 응시자 전원을 감독할수 있다면 즉, 총감독관이 감시할수 있는 인원을 제외했을때 오히려 0이나
// 음수가 나온다면 부감독관은 필요가 없어진다. 이것을 그대로 구현하면 된다.

// 자세한 설명은 주석으로 남긴다.

int board[1000000];
int N, B, C;

void MakeAnswer()
{
    // 각 시험장에서 최대 100만에 가까운 감독관이 필요할때가 존재하는데 시험장은 최대 100만개가 존재하여
    // int값을 벗어날수 있으므로 long long 타입의 변수를 사용해야 한다.
    long long answer = 0;
    // 모든 시험장을 순회한다.
    for (int i = 0; i < N; ++i)
    {
        // 먼저 총감독관이 감시할수 있는 인원을 제외하고
        // 총감독관을 추가한다.
        board[i] -= B;
        ++answer;
        // 만약 총감독관이 모든 응시자들을 감시할수 없다면
        // 부감독관을 추가한다.
        if (board[i] > 0)
        {
            // 부감독관이 감시할수 있는 인원으로 응시자들을 나누어 
            // 부감독관의 인원을 구한다.
            answer += board[i] / C;
            // 만약 나머지가 생긴다면 한명 더 추가한다.
            if (board[i] % C != 0)
                ++answer;
        }
    }

    cout << answer << '\n';
}

void Input()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> N;
    for (int i = 0; i < N; ++i)
        cin >> board[i];
    cin >> B >> C;
}

int main()
{
    Input();
    MakeAnswer();
    return 0;
}