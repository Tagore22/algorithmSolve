#include <iostream>
#include <algorithm>

using namespace std;

// 풀이.
// 처음에는 아무 생각없이 백트래킹을 이용한 완전탐색으로 풀었다.
// 당연히 메모리초과 및 시간초과가 떴다. 문자열의 길이가 최대 999이기 때문에 당연한 결과였다.
// 진짜 풀이는 그리디였는데 S에서 T로 만드는것보다 T에서 S로 만드는게 더 쉬운 방법이었다.
// 왜냐하면 S에서 T로 만드는것은 2가지 1번방법과 2번방법의 2가지 경우가 존재하기에 2의 제곱만큼
// 계속 늘어난다. 하지만 T에서 S로 만드는것은 마지막 문자만 보면 알수 있기에 무조건 1가지 경우밖에 없기 때문이다.

// 1. 마지막 문자가 A일 경우 - 1번 방법을 사용한 후임. 그러므로 마지막 문자만 제거하면 된다.
// 2. 마지막 문자가 B일 경우 - 2번 방법을 사용한 후임. 그러므로 마지막 B를 제외하고 뒤집으면 된다.

// 경우의 수가 루트만큼 줄어들고 중복 확인할 필요도 없다.

// 자세한 설명은 주석으로 남긴다.

string S, T;

void MakeAnswer()
{
    while (true)
    {
        // S와 T의 길이가 같아질때까지 반복한다.
        if (T.size() == S.size())
        {
            // 두 문자가 같다면 1을 그렇지 않다면 0을 출력하고 탈출한다.
            cout << (S == T ? 1 : 0) << '\n';
            return;
        }

        // 상술한 1번 방식으로 마지막 문자가 A라면 1번 방법을 쓰고 난 후이기에 
        // 이전으로 되돌리기 위해서는 마지막 문자만 지우면 된다.
        if (T[T.size() - 1] == 'A')
        {
            T.pop_back();
        }
        // 상술한 2번 방식으로 마지막 문자가 B라면 2번 방법을 쓰고 난 후이기에
        // 이전으로 되돌리기 위해서는 마지막 문자를 지우고 뒤집으면 된다.
        else
        {
            T.pop_back();
            reverse(T.begin(), T.end());
        }
    }
}

void Input()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> S >> T;
}

int main()
{
    Input();
    MakeAnswer();
    return 0;
}