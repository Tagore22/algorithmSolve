#include <iostream>

using namespace std;

// 풀이.
// 단순한 비틀기인데 구현을 짧고 간단하게 하기 위해 시간을 좀 썼다.
// 문제 자체는 간단한데 동전의 수를 최소로 하기 위해서는 최대한 큰수로 나누어야 한다. 즉 5로 최대한 나누어야하는데
// 5로 나눈 나머지가 2의 배수가 아닐때에 문제가 발생한다. 이때는 나머지가 홀수가 되기 때문이다. 해결방안은 5로 한번
// 덜 나누는 것이다. 그러면 남은 홀수와 5를 더해 무조건 짝수가 되기 때문에 2로 나눌수 있다. 

// 자세한 설명은 주석으로 남긴다.

int main()
{
    int N;
    cin >> N;

    // N이 1이거나 3일때에는 나눌 방법이 없다.
    if (N == 1 || N == 3)
    {
        cout << -1 << '\n';
    }
    else
    {
        int div = N % 5;
        // 상술한대로 5로 나눈 나머지가 짝수일때에는 문제가 없다. 나머지를 2로 나누고 각각 나눈 수를 더하여
        // 출력하면 된다. 하지만 나머지가 홀수일때가 문제가 된다. 이때에는 5로 한번 덜 나누어서 나머지 값과
        // 5를 더해 짝수를 만들어주면 된다. 이때 기존 홀수를 2로 나눈 나머지 1과 덜 나눈 5를 더해 6이 되어
        // 2로 거슬러 줄수 있는 동전의 수가 3이 증가하게 되고, 5로 거슬러 줄수 있는 동전의 수가 1 감소하게 된다.
        cout << (div % 2 == 0 ? N / 5 + N % 5 / 2 : N / 5 - 1 + N % 5 / 2 + 3) << '\n';
    }
    return 0;
}