#include <iostream>
#include <stack>

using namespace std;

// 풀이.
// 스택을 이용한 문제였는데 로직이 잘 떠오르질 않았다. 결과적으로 약간 재귀방식을 응용한 로직을
// 구현해야했는데 대략 다음과 같다.

// 1. )을 만나면 새로운 곱셈연산이 시작됨으로 기존의 Q값을 스택에 넣어 보존한다.
// 2. (를 만날때까지 새로운 Q값을 구한다.
// 3. (를 만난다면 그 이후는 무조건 곱해지므로 IsK를 true로 바꾸어 그 다음값에서 곱해야함을 알린다.
// 4. 현재 Q값을 곱하여 새로운 Q를 만들고 스택에 존재하는 기존의 Q값을 더해주어 최종적으로 Q값을 구한다.


// 이것을 반복하면 된다. 실패하는 경우는 주어지지 않으므로 (와 )은 무조건 쌍을 이루기에 마지막에 스택값을 검사할
// 필요는 없다.

// 자세한 설명은 주석으로 남긴다.

int main()
{
    string str;
    cin >> str;
    // (를 만나서 다음에 곱해야하는지를 알리는 변수.
    bool IsK = false;
    int Q = 0;
    stack<int> sta;
    for (int i = str.size() - 1; i >= 0; --i)
    {
        // )를 만날시 새로운 곱셈연산이 시작됨으로 현재 Q값을 스택에 저장하고
        // Q를 0으로 초기화한다.
        if (str[i] == ')')
        {
            sta.push(Q);
            Q = 0;
        }
        // (를 만날시 이 다음에 곱셈연산이 시작됨으로 IsK를 true로 갱신한다.
        else if (str[i] == '(')
        {
            IsK = true;
        }
        // 숫자를 만날시 이루어지는 연산은 총 2가지인데 IsK에 의해 나누어진다.
        // IsK가 true일시 현재값을 Q에 곱하고 스택에 있는 기존 Q값을 더하여 최종 Q값을 구하거나
        // IsK가 false일시 그냥 현재 Q값에 1이 더해진다.
        else
        {
            if (IsK)
            {
                int num = str[i] - 48;
                Q *= num;
                Q += sta.top();
                sta.pop();
                IsK = false;
            }
            else
            {
                Q += 1;
            }
        }
    }
    // 최종 Q값을 출력한다. 상술한대로 무조건 성공하는 경우만 주어지므로 (와 )의 쌍을 검사할 필요는 없다.
    cout << Q << '\n';
    return 0;
}