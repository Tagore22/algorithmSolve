#include <iostream>

using namespace std;

// 풀이.
// 그리디 문제라 생각해내는데 오래 걸렸다. 정답율이 꽤나 낮은 것도 있었지만.
// 우선 동시에 1과 2를 쓰기 때문에 모든 나무들의 높이는 3의 배수여야만 한다. 이것을 가지치기로 쳐낸다.
// 그 이후 각각 1과 2의 쓰인 횟수를 알아내야 한다. 왜냐하면 예제 4번을 보면 총합은 9지만 2번 나무와 4번 나무가
// 불가능하기 때문이다. 2가 3번쓰여서 총합이 6인건 맞지만 3과 3으로 나눌순 없다. 4와 2나 2와 4가 되어야 한다.
// 따라서 모든 원소들을 돌면서 2가 쓰인 횟수부터 구한후 그 값을 제외하고 나머지를 1이 쓰인 횟수로 계산하여
// 쓰인 횟수가 동일한지를 확인하면 된다.

// 자세한 설명은 주석으로 남긴다.

// P.S 무리하게 일찍 일어나서 그런지 머리가 잘 안돌아간다. 그렇기에 상술한 풀이가 조금 대충인 느낌이 있다.
// 그렇기에 조금더 상세하게 기록하고자 한다. 우선 총합이 3의 배수인지는 매우 명확하다. 하지만 상술한 예제 4번을
// 보면 조금더 조건이 필요함을 알수 있는데 예제 4번의 문제는 2가 둘로 쪼개져 있는 상태가 존재한다는 것이다. 
// 3과 3이 그 예시이다. 이런 경우를 검출해내기 위해서는 쪼개질 가능성이 존재하는 2번부터 계산해야 한다.
// 그러면 2번은 쪼개질 가능성 없이 무조건 온전히 사용하는 경우가 되며 나머지를 1로 메꾸면 된다.
// 따라서 모든 원소를 순회하며 무조건 2번부터 계산한다.

int board[100000];
int N, sum = 0;

void MakeAnswer()
{
    // 총합이 3의 배수가 아니라면 애시당초 불가능하다.
    if (sum % 3 != 0)
    {
        cout << "NO" << '\n';
        return;
    }

    // 1과 2가 쓰여져야만 하는 횟수.
    int one = sum / 3;
    int two = one;

    for (int i = 0; i < N; ++i)
    {
        // 아직 2가 더 쓰일수 있다면 쓸수 있는 최대값을 구해 빼준다.
        // 그 이후 나머지를 1이 쓰인 횟수로 하면 딱 알맞다.
        // 왜 2를 먼저 계산하냐면 1을 먼저 계산했을때 남은 높이들의 총합이
        // 2의 배수일지라도 상술한 예제 4번처럼 그 순서가 불가능할 경우가 있기 때문이다.
        // 어차피 1의 배수는 모든 수이기 때문에 2의 배수부터 구하고 나머지를 1의 배수로 치면 된다.
        if (two > 0)
        {
            int minus = min(two, board[i] / 2);
            two -= minus;
            board[i] -= minus * 2;
        }
        one -= board[i];
    }

    // 둘이 같은 횟수로 쓰였는지에 따라 답이 나뉘어진다.
    if (one == 0 && two == 0)
        cout << "YES" << '\n';
    else
        cout << "NO" << '\n';
}

void Input()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> N;
    for (int i = 0; i < N; ++i)
    {
        cin >> board[i];
        sum += board[i];
    }
}

int main()
{
    Input();
    MakeAnswer();
    return 0;
}