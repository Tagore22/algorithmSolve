#include <iostream>

using namespace std;

// 풀이.
// 처음엔 완전탐색인가 했는데 최대값이 42억을 돌파해서 불가능했다.
// 결국엔 수학적인 접근이 필요했고 풀이의 큰틀은 다음과 같다.

// 1. 현재값 long long타입의 cur은 0에서 시작한다.
// 2. cur에 1부터 1씩 증가하는 값들을 더해준다.
// 3. S보다 커질때까지 더해주다가 S보다 커지면 S보다 큰만큼의 수를 빼고 현재 수를 넣으면 된다.
// ex) S가 4일때, 1부터 더해주다가 6이 되어 커지면 2를 제외하고 그자리에 3을 넣으면 된다.

// 이 방식은 쉽게 증명이 가능한데, 1씩 더해지다가 S보다 커진다면 그 차이는 무조건 현재값보다 작다.
// 1. 차이가 현재값보다 클때 - 아예 불가능하다. 애시당초 현재값이 S보다 커야만 이럴수있다.
// 2. 차이가 현재값과 같을때 - 이전에 이미 답을 찾은 상태.

// 이렇기 때문이다. 따라서 현재 더해주는 값과 더해진 횟수를 하나로 연동하여
// 현재값이 S보다 커졌을때 - 2값을 출력하면 된다.

// 자세한 설명은 주석으로 남긴다.

long long S;

void MakeAnswer()
{
    // 현재값과 더해진 값(더해진 횟수 + 1).
    long long cur = 0;
    int plus = 1;

    // 현재값이 S보다 작다면 계속 반복한다.
    while (cur <= S)
    {
        // 현재값에 1부터 증가하는 값을 게속 더해준다.
        cur += plus;
        ++plus;
    }

    // 상술한대로 현재값이 S보다 커졌을때의 횟수에서 2를 빼고 출력한다.
    // 1. 부족한 부분을 제외하였기에 -1.
    // 2. 횟수가 연동을 위해 0이 아닌 1부터 시작했기에 -1.
    cout << plus - 2 << '\n';
}

void Input()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> S;
}

int main()
{
    Input();
    MakeAnswer();
    return 0;
}