#include <iostream>
#include <queue>

using namespace std;

// 풀이.
// 최대한 트럭들을 묶어서 한번에 다리를 통과시켜야 최소시간이 나오기 때문에
// 처음에는 묶을수 있는 만큼 묶어서 건너는 시간들의 총값을 구했었다.
// 하지만 이 방법은 틀렸는데 그 이유는 뭉탱이 별로 다리를 모두 건너도 그 다음에 다음 뭉탱이가 건너기 때문이다.
// 예를 들어 예시 1번인 4 2 10 7 4 5 5 를 보면 7은 홀로 건너도 4와 5가 같이 건널수 있다. 이 이후가 중요한데
// 4가 건너고 첫번째 5가 다리위에 있을때 두번째 5 역시 다리위에 올라갈수 있다.
// 하지만 상술한 방법으로는 4와 첫번째 5가 모두 건넌 이후에 두번째 5가 올라가는 것으로 계산하기 때문에
// 정답이 될수 없는 것이다.

// 제대로 된 풀이는 deque를 이용하였는데 deque의 첫번째 원소를 제외한후(모든 트럭들이 한칸 앞으로 이동함)
// 마지막 부분에 조건문을 걸어 0 혹은 다음 원소를 집어넣는다(마찬가지로 모든 트럭들이 한칸 앞으로 이동)
// 이것을 다리위에 무게의 합이 0이 될때까지 반복해주면 된다.

// 자세한 설명은 주석으로 남긴다.

int board[1000];
int N, W, L;

void MakeAnswer()
{
    // 덱의 가장 앞을 지운다. 
    // 현재 덱의 무게가 그 다음과 더했을때 올라올수 있다면 다음이 올라온다.
    // 그렇지 않다면 0이 올라간다.

    // 다리를 구현한 deque.
    deque<int> deq(W - 1, 0);
    // 상술하였듯 다리위의 무게가 0이 될때가 조건문의 탈출 조건이기 때문에 첫번째 원소를 이미 다리위에
    // 올려놓고 시작한다. 그렇기에 시간의 초기값 역시 1로 시작한다.
    deq.push_back(board[0]);
    // 다리위의 무게값.
    int sum = board[0];
    // 0번째 원소를 이미 다리위에 올려놓고 시작하기에 현재 원소는 1번째로 시작한다.
    int idx = 1;
    // 상술하였듯 0번째 원소를 미리 다리위에 놓고 시작하기에 시간은 1로 시작한다.
    int answer = 1;

    // 다리위의 무게가 0일때까지 반복함. 모든 트럭은 최소 한개 이상은 무조건 다리위에 올려놓을수 있으니
    // 다리위의 무게가 0이라는 것은 모든 트럭이 다리를 지나갔음을 뜻한다.
    while (sum != 0)
    {
        // 모든 트럭이 1칸 앞으로 움직이므로 맨 앞 트럭의 무게를 줄이고
        // 맨 앞 트럭을 제외시킨다.
        sum -= deq.front();
        deq.pop_front();

        // 현재 idx번째 원소를 다리위에 올려놓아도 된다면
        // 무게값을 늘리고 deque에 idx번째 원소를 추가한다.
        if (sum + board[idx] <= L)
        {
            deq.push_back(board[idx]);
            sum += board[idx];
            ++idx;
        }
        // 그렇지 않다면 트럭을 올릴수 없으니 0(추가되는 무게가 없음)을 추가한다.
        else
        {
            deq.push_back(0);
        }
        ++answer;
    }
    cout << answer << '\n';
}

void Input()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> N >> W >> L;
    for (int i = 0; i < N; ++i)
        cin >> board[i];
}

int main()
{
    Input();
    MakeAnswer();
    return 0;
}