#include <iostream>

using namespace std;

// 풀이.
// 어려운 문제라기보다는 내가 모르는 수학적 공식을 이용하는 문제였기에 알수가 없었다.
// 포함 배제의 원리는 대체 어디서 나온건가.. 결과적으로는 이런뜻이다.
// 1쌍의 포카드를 미리 만들어놓고 나머지 카드들을 고르는 경우 - 2쌍의 포카드 + 3쌍의 포카드 - 4쌍의 포카드...이다.
// 예를 들어 9개의 카드를 뽑을때 1쌍의 포카드를 미리 만들어놓고 나머지에서 5장을 고를때 또다른 포카드를 만들수도 있다.
// 이때 2쌍의 포카드를 만든것이 2가지가 생긴다. 처음에 1번 포카드쌍을 집고 2번 포카드를 집은상태에서 나머지 하나를 고를때와
// 처음에 2번 포카드쌍을 집고 1번 포카드를 집은상태에서 나머지 고를 하나가 바로 그것이다. 따라서 2쌍의 포카드를 미리 만들어놓고
// 나머지 1가지를 고를때를 빼준다면 중복을 완벽하게 제거할수 있다. 이 논리에 의해서 홀수쌍의 포카드는 더하고
// 짝수쌍의 포카드는 빼면 된다. 다만 후술할 부분은 주의해야한다.

// 자세한 설명은 주석으로 남긴다.
// 포함 배제의 원리... 잘모르겠었으나 일단 기억해두자.
// 조금더 찾아봤다. 정리해두자.

// 포함 배제의 원리는 원소 A1 ~ AN이 존재할때 모든 원소의 합집합은
// 모든 원소의 합 - A1 ~ A2의 교집합 + A1 ~ A3의 교집합 - A1 ~ A4의 교집합....이라는 것이다.
// 위 문제에 대입해보면 문제에서 최소한 1쌍이상의 포카드를 찾았으므로 13쌍의 포카드중 딱 하나를 고른 상태에서의
// 모든 상태가 답이 되며 이것이 모든 원소의 합이 된다. 그 이후 포카드를 2쌍집고 시작하는 경우가 A1 ~ A2의 교집합이 되며
// 다시 3쌍집고 시작하는 것이 A1 ~ A3의 교집합이 된다. 실제로 대입해보면 12개의 카드를 집을때 1쌍의 포카드를 집고 시작해도
// 나머지 8장으로 또다른 포카드를 집을수 있고, 2쌍의 포카드를 집고 시작해도 나머지 4장으로 또다른 포카드를 집어 총
// 3쌍의 포카드가 될수 있다. 결국 포함배제의 원리에 딱 떨어지게 된다.

int dp[53][53];
const int DIV = 10007;
int N;

// from개의 카드중 num개의 카드를 집을때 포카드를 집는 경우의 수.
int Select(int from, int num)
{
    // 중복이 발생할수가 있기에 DP처리한다.
    int& ans = dp[from][num];
    if (ans != 0)
        return ans;
    // 만약 0개 혹은 모두를 집는다면 조합 공식에 의거하여 1을 반환한다.
    if (num == 0 || num == from)
        return 1;
    // 마찬가지로 조합 공식에 의거하여 nCr = n-1Cr + n-1Cr-1이 된다. 
    ans = (Select(from - 1, num) + Select(from - 1, num - 1)) % DIV;
    return ans;
}

int main()
{
    cin >> N;
    int answer = 0;
    // 집을수 있는 포카드의 수는 주어지는 수 N / 4개까지이다.
    for (int i = 1; i <= N / 4; ++i)
    {
        // 상술한대로 홀수는 더하고 짝수는 뺀다.
        if (i % 2 == 1)
        {
            answer += (Select(13, i) * Select(52 - i * 4, N - i * 4)) % DIV;
            answer %= DIV;
        }
        else
        {
            answer -= (Select(13, i) * Select(52 - i * 4, N - i * 4)) % DIV;
            // 이 부분이 중요한데 음수가 발생할수도 있다. 하지만 경우의 수는 음수가 없기에
            // 다시 DIV값을 추가하여준다. 실제로 양수일때에는 정수론에 의거하여 값이 변하지 않는다.
            answer = (answer + DIV) % DIV;
        }
    }
    cout << answer << '\n';
    return 0;
}