#include <iostream>

using namespace std;

// 풀이.
// 처음에는 안일하게 가장 외곽에 괄호를 붙이는 것과 오른쪽에 괄호를 추가하는 것으로
// 기존 값 * 2를 생각해서 너무 안일하게 풀었다. 그 후에 떠오른건 언젠가 풀었던 타일
// 문제였다. 그 문제에는 앞에서부터 풀어나가는 방식이었으나 그 방식은 이곳에 대입하기
// 어려웠다. 정답은 가장 외곽에 괄호를 지우고 두 부분으로 나누는 것이었다. 처음에는 
// 이해가 어려웠는데 예를 들어 dp[6] += dp[0] * dp[4]가 되는 것인데 0과 4나 4과 0이나
// 다름을 느끼지 못했기 때문이다. 이건 상술한 타일 문제에서도 잘 이해가 가지 않았듯이 없음
// 을 뜻하는 dp[0]이 1이기 때문이다. 따라서 dp[0] * dp[4]는 dp[4] * dp[0]과 같은게 아닌
// 대칭이 된다.

// 자세한 설명은 주석으로 남긴다.

// P.S 조금 더 자세히 이해하기 위해 이것저것 찾아봤다. 설명하자면
// 올바른 괄호는 (로 시작해서 )로 끝나야한다. (로 시작해서 )가 언제 
// 나오는지에 따라 달라진다. 단순히 외곽의 괄호와는 상관이 없는 것이다. 
// 예를 들어 길이가 4일 때 ()()는 올바른 괄호지만 외곽의 괄호를 따지면
// 길이가 2일 때 )(인 경우가 되어 이상해진다. 따라서 (로 시작해서 바로 )가
// 등장한 경우라면 나머지가 ()가 되니 이해하기 수월해진다. 또한 0, 6과 6, 0은
// 같은 경우이기에 중복되는 것이 아닌가에 대한 답은 말 그대로 0, 6과 6, 0로
// 순서가 다르며 0인 경우가 엄연히 1가지 상황이 주어지기에 다르게 취급하는 듯 하다.

const int DIV = 1000000007;
int T, N;
long long board[5001];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    board[0] = 1;
    for (int i = 2; i <= 5000; i += 2)
    {
        // 가장 외곽 괄호를 지우고 두 부분으로 나누어 계산한다.
        // 문제에 올바른 괄호는 외곽의 괄호를 씌운 경우와 올바른 괄호를
        // 이어 붙일 때라고 명시되어 있기 때문이다.
        for (int j = 0; j < i; j += 2)
        {
            board[i] += board[j] * board[i - 2 - j];
            board[i] %= DIV;
        }
    }

    cin >> T;
    for (int iter = 0; iter < T; ++iter)
    {
        cin >> N;
        cout << board[N] << '\n';
    }
    return 0;
}