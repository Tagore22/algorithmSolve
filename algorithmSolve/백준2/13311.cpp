#include <iostream>

// 풀이.
// 문제를 잘 보면 합동식이 나온다. 처음에는 대충 봐서 = 인줄 알았다.
// 사실 합동식도 처음 본 내용인데 n ≡ a­-1 (mod a)을 정리해보자면
// n을 a로 나눈 나머지값과 a - 1을 a로 나눈 나머지값이 일치한다는 것이다.
// 예를 들어 a를 5라고 치면 n은 기본적으로 4가 된다. 하지만 추가적으로
// 4에서 a값인 5를 빼고 더할 수가 있다. 그래서 음수쪽을 보면 -1, -6, -11등이
// 있고, 양수쪽을 보면 9, 14, 19, 24등이 있다. n은 이런 모든 수들을 뜻하는 것이다.
// 따라서 1 ~ 1000까지에서 주어진 합동식을 늘 만족하는 수를 구해야 한다.
// 이 경우 -1과 1 ~ 1000의 최소공배수 -1 등이 있으나 후자는 문제에서 알려준
// 범위 값을 벗어나기에 -1을 출력하면 된다. 또한, 1 ~ 1000의 최소공배수 - 1인
// 이유는 생각해보면 간단한데 기본값은 늘 a - 1이다. 여기서 a만큼 늘 증가하는데
// 이를 a를 k번 곱한 결과라고도 볼 수 있기 때문이다. 시작값이 - 1된 상태였기에
// 결과적으로 1 ~ 1000의 최소공배수 - 1이 된다. 정수론 즉, 모듈라 연산에서
// 이 합동식이 사용된다.

int main()
{
    std::cout << -1 << '\n';
    return 0;
}