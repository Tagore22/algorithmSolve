#include <iostream>

using namespace std;

// 풀이.
// 2가지 실수를 했다. 너무 어렵게 생각한게 아닌가 싶다.

// 1. 대응되는 두 부분이 모두 ?일때 질의는 최소 27인줄 알았다. 어느 한쪽에
// 26개를 모두 대입하고 나머지 부분에 한번의 질문이 아닌가 싶었기 때문인데
// 실제로는 한쪽에 25개를 대입하고 나머지 부분에 남은 한개의 알파벳을 대입
// 하면 된다. 

// 2. 대응되는 두 부분이 모두 ?이 아닌데 다를 경우가 문제였다. 말 그대로
// 어떤 순서로 접근했는 지에 따라 다르다고 잘못 생각하고 있었다. 그냥 
// 다른 두 부분을 맨 처음에 검사하면 0번의 질의로 알아낼 수 있기에 
// 그냥 0을 출력하면 되었다.

// 자세한 부분은 주석으로 남긴다.

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    int N;
    string str;
    cin >> N >> str;

    int answer = 0;
    for (int i = 0; i < N / 2; ++i)
    {
        // 두 부분이 다를 때.
        if (str[i] != str[N - i - 1])
        {
            // 둘중 하나가 ?이라면 한번의 질의면 된다.
            if (str[i] == '?' || str[N - i - 1] == '?')
            {
                ++answer;
            }
            // 둘다 ?가 아니라면 무조건 팰린드롬이 아닌 경우이므로
            // 이 부분을 맨 처음에 검사하였다고 치면 0번의 질의로
            // 알아낸 것이 된다.
            else
            {
                answer = 0;
                break;
            }
        }
        // 두 부분이 같을 때.
        else
        {
            // 한쪽이 ?이라면 다른 한쪽도 무조건 ?이므로 상술한대로
            // 26번의 질의가 필요하다. 한쪽에 25개의 알파벳을 대입하고
            // 나머지 한쪽에 마지막 알파벳을 대입하면 된다.
            if (str[i] == '?')
                answer += 26;
            // 두 부분이 같은데 ?이 없는 경우는 그냥 넘어가면 된다.
        }
    }
    cout << answer << '\n';
    return 0;
}